{"version":3,"file":"submodule-docdash.min.js","sources":["../node_modules/style-inject/dist/style-inject.es.js","../src/web/scripts/shared/regex.js","../src/web/scripts/shared/render.js","../src/web/scripts/docdash/parse.js","../src/web/scripts/docdash/index.js","../src/web/scripts/docdash/mount.js"],"sourcesContent":["function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","// Copyright (c) 2022 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.\n//\n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Defines regexps required for parsing the existing nav into a module\n *      tree\n * @module shared/regex\n * @author James Reid\n */\n\n// @ts-check\n\n// @body\n/**\n * Captures module name from href\n *\n * @static\n * @type {RegExp}\n */\nconst moduleRegex = /(?<=\\/module-).*(?=\\.html)/;\n\n/**\n * Creates absolute path for a given module name, separating with underscores\n * rather than slashes, and including a leading character\n *\n * @static\n * @type {string}\n */\nconst windowLocation = window.location.href.endsWith(\".html\")\n  ? window.location.href\n  : window.location.href + \".html\";\n\nconst absolutePath = `_${windowLocation.match(moduleRegex)?.[0] || \"\"}`;\n\n/**\n * Captures module name, but only matches if the link if it includes an id at\n * the end (note trailing #)\n *\n * @static\n * @type {RegExp}\n */\nconst methodRegex = /(?<=\\/module-).*(?=\\.html#)/;\n\n/**\n * Captures a root path module (i.e. a path with no nesting: _root vs _not_root)\n *\n * @static\n * @type {RegExp}\n */\nconst rootPathRegex = /^_[^_]*$/;\n\n/**\n * Captures direct child path from calculated absolute path (i.e. paths which\n * are direct children of absolute path: _absolute_path_child vs\n * _absolute_path_not_child)\n *\n * @static\n * @type {RegExp}\n */\nconst childPathRegex = new RegExp(`^${absolutePath}${/_[^_]*$/.source}`);\n\n/**\n * Captures sibling paths from calculated absolute path (i.e. paths which are\n * at the same nested level as the absolute path: _absolute_path is sibling to\n * _absolute_sibling, but not to _absolute nor _absolute_path_child). This regex\n * is calculated programmatically, and is therefore not declared in a const\n * assignment, but is marked as readonly as it should not be changed elsewhere.\n *\n * @static\n * @readonly\n * @type {RegExp}\n */\nlet siblingPathRegex = /(^_[^_]*$)/;\nlet siblingScopePath = \"\";\nfor (const scope of absolutePath.split(\"_\").slice(1)) {\n  siblingScopePath = `${siblingScopePath}_${scope}`;\n  const regex = new RegExp(`(^${siblingScopePath}${/_[^_]*$/.source})`);\n  siblingPathRegex = new RegExp(`${siblingPathRegex.source}|${regex.source}`);\n}\n\n// named capture groups for access and scope - required by methodSignatureRegex\nconst accessRegex = /(?<access>(public|package|protected|private))/;\nconst scopeRegex = /(?<scope>(global|instance|static|inner))/;\n\n/**\n * Captures a method signature regardless of if only access or only scope, both,\n * or no signature is rendered\n *\n * @static\n * @type {RegExp}\n */\nconst methodSignatureRegex = new RegExp(\n  `(\\\\()?${accessRegex.source}?(,\\\\s)?${scopeRegex.source}?(\\\\))?`,\n  \"i\"\n);\n\n// @exports\nexport {\n  moduleRegex,\n  methodRegex,\n  rootPathRegex,\n  childPathRegex,\n  siblingPathRegex,\n  methodSignatureRegex,\n  absolutePath,\n};\n","// Copyright (c) 2022 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.  \n// \n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Defines shared render method for the nested nav given a mount supplied\n *      mount point\n * @module shared/render\n * @author James Reid\n */\n\n// @ts-check\n\n// @imports-style\nimport \"../../styles/style.css\"\n// @imports-module\nimport { absolutePath } from \"./regex.js\"\n// @imports-type\nimport { NestedModule } from \"../../types/NestedModule.js\"\n\n// @body\n/**\n * Render nested module nav to a target container within the original jsdoc\n * template nav. Nesting determined by moduleTree reflecting the code/module\n * structure. Function directly renders to the passed moduleNavContainer html\n * element. Recursively called for all children within module tree.\n * \n * @summary Render nested module nav\n * @static\n * @param {HTMLElement} moduleNavContainer - target html element for rendering \n *      nested module nav\n * @param {NestedModule[]} moduleTree - calculated module tree to re-render in\n *      a nested format\n * @returns {void} \n */\nconst renderNestedModules = (moduleNavContainer, moduleTree) => {\n    // create root list element for current location/nest level on module tree\n    const list = document.createElement(\"ul\")\n\n    // loop over each nested module at the top level of the current\n    // location/nest level of the module tree, and render required nav elements\n    let scope\n    for (const fragment of moduleTree) {\n        // if fragment scope has changed since the last fragment, add title\n        // reflecting scope of following method(s) - groups methods of same \n        // scope under titles in nav\n        if (fragment.scope && scope != fragment.scope) {\n            scope = fragment.scope\n            const title = document.createElement(\"li\")\n            title.classList.add(\"method-scope-title\")\n            title.innerHTML = `${fragment.scope} methods`\n            list.appendChild(title)\n        }\n\n        // create list element for given fragment, and populate attributes from\n        // fragment data\n        const listItem = document.createElement(\"li\")\n        listItem.dataset.type = fragment.type\n        listItem.classList.add(...(() => {\n            const { type, hierarchy, access, scope } = fragment\n            const classList = /** @type {string[]} */ ([type, hierarchy])\n            if (access && scope) { \n                classList.push(`access-${access}`, `scope-${scope}`)\n            }\n            return classList\n        })())\n\n        // create link element for the given fragment, populate attributes from\n        // fragment data, and nest inside list element\n        const link = document.createElement(\"a\")\n        link.innerHTML = fragment.name\n        link.href = fragment.href\n        listItem.appendChild(link)\n        \n        // if there are children, recursively call render function for each\n        // child then add result to root list element\n        if (fragment.children.length) { \n            renderNestedModules(listItem, fragment.children) \n        }\n        list.appendChild(listItem)\n    }\n\n    // add result to DOM\n    moduleNavContainer.appendChild(list)\n}\n\n/**\n * Render nested module title be separating dirname and basename of module into\n * separate spans for styling purposes. Function directly renders to the passed \n * title html element.\n * \n * @summary Render nested module title\n * @static\n * @param {HTMLHeadingElement} title \n * @returns {void}\n */\nconst renderNestedTitle = title => {\n    // only re-render title when part of a nested (non top level) module\n    if (absolutePath != \"_\") {\n        // add nested rendering specific class for styles\n        title.classList.add(\"nested-title\")\n\n        // fetch and split nested module name from url\n        const splitPath = absolutePath.split(\"_\").slice(1)\n        const [last, init] = [ \n            /** @type {string} */ (splitPath.pop()), \n            splitPath \n        ]\n\n        // render parent names (dirname) and basename in separate spans\n        const spanInit = document.createElement(\"span\")\n        spanInit.innerHTML = init.length ? `${init.join(\" → \")} → ` : \"\"\n        const spanLast = document.createElement(\"span\")\n        spanLast.innerHTML = last\n\n        // reset title and render nested module title\n        title.innerHTML = \"\"\n        title.append(spanInit, spanLast)\n    }\n}\n\n// @exports\nexport { renderNestedModules, renderNestedTitle }","// Copyright (c) 2022 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.  \n// \n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Method for parsing modules from the docdash DOM into a nested module\n *      tree object for later re-render.\n * @module docdash/parse\n * @author James Reid\n */\n\n// @ts-check\n\n// @imports-types\nimport { NestedModule } from \"../../types/index.js\"\n// @imports-local\nimport {\n    methodRegex,\n    childPathRegex,\n    siblingPathRegex,\n    methodSignatureRegex,\n    absolutePath\n} from \"../shared/index.js\"\n\n// @body\n/**\n * Parses existing nav into a nested structure for re-render by nesting modules\n * according to their pathname (i.e. \"folder/subdirectory\" would be nested \n * underneath a top level module named \"folder\").\n * \n * Apart from some DOM manipulation which is specific to docdash, much of the \n * logic below could be shared with other templates when they are added.\n * \n * @summary Parses existing nav into a nested structure for re-render\n * @tutorial module-fragments\n * @static\n * @param {HTMLUListElement} navList - Original modules nav list\n * @returns {NestedModule[]}\n */\nconst parseModules = navList => {\n    /** \n     * Declare array to be returned - will be populated with top level modules\n     * @type {NestedModule[]} \n     */\n    const moduleTree = []\n\n    // Loop over list elements contained within the original navList \n    for (const childNode of navList.querySelectorAll(\":scope > li\")) {\n        // if multiple files share a module name, autogenerated docs will spawn\n        // extra empty lists for each file, ignore these empty lists\n        if (!childNode.firstChild) { continue }\n        \n        // fetch relevant data from childNode - note that the links nested in by\n        // one level in the docdash template are always methods which are \n        // members of the given module\n        const link = /** @type {HTMLLinkElement} */ \n            (childNode.querySelector(\":scope > a\")) \n        const methods = /** @type {NodeListOf<HTMLLinkElement>} */\n            (childNode.querySelectorAll(\":scope > ul > li > a\")) \n        const splitPath = link.innerHTML.split(\"/\")\n        const [last, init] = [ \n            /** @type {string} */ (splitPath.pop()), \n            splitPath \n        ]\n\n        // isolate \"first-parent\" scope of childNode within moduleTree - if the\n        // scope does not yet exist, add it on the fly \n        let scope = moduleTree\n        let dir = \"\"\n        for (const name of init) {\n            let inner = scope.find(obj => obj.name === name)\n            if (!inner) {\n                inner = getFragment({ name, link, dir })\n                scope.push(inner)\n            }\n            // update file type fragments to module fragments since submodule \n            // is being added\n            if (inner.type === \"file\") {\n                Object.assign(inner, { type: \"module\" })\n            }\n            scope = inner.children\n            dir = inner.path\n        }\n\n        // look for existing module fragment with the same final basename - this\n        // is for accounting for the \"ignored\" filename (default index.js) which\n        // could be parsed after sibling modules if jsdoc is not generated with\n        // sort option set to true in config -> i.e. given two files \n        // \"src/path/feature.js\" (module name \"src/path/feature\") and\n        // \"src/path/index.js\" (module name \"src/path\"), the feature module will\n        // be parsed first\n        const inner = scope.find(obj => obj.name === last)\n        if (inner) { \n            // case where fragment with same basename exists and existing\n            // fragment must be updated\n            Object.assign(inner, { type: \"module\", href: link.href })\n            for (const link of methods) {\n                inner.children.push(getFragment({ \n                    name: link.innerHTML, \n                    link, \n                    dir: inner.path\n                }))\n            }\n        }\n        else { \n            // case where fragment with same basename does not exist and a new\n            // fragment must be created\n            const children = []\n            for (const link of methods) {\n                children.push(getFragment({ \n                    name: link.innerHTML, \n                    link, \n                    dir: `${dir}_${last}`\n                }))\n            }\n            scope.push(getFragment({ name: last, link, dir, children }))\n        }        \n    }\n\n    // sort entire module tree as last step, ensuring that final rendered\n    // nested nav will reflect more closely the hierarchy of src directory\n    sortModuleTree(moduleTree)\n    return moduleTree\n}\n\n/**\n * Recursively sort nested module tree **in place** such that all nested modules\n * have been sorted - see [here]{@link module:docdash/parse~getPriority} for \n * function used in sorting.\n * \n * @summary Recursively sort nested module tree\n * @param {NestedModule[]} moduleTree - Module tree to be sorted\n * @returns {void}\n */\nconst sortModuleTree = moduleTree => {\n    // end if no children, otherwise recurse function for all children and sort\n    // current array in place\n    if (!moduleTree.length) { return }\n    for (const { children } of moduleTree) { sortModuleTree(children) }\n    moduleTree.sort((optA, optB) => getPriority(optA, optB))\n}\n\n/**\n * Get priority between two given nested module for which should appear first\n * in the nested module nav. Modules are ordered as follows with priority\n * decreasing down the list (i.e. first by type, last by alphabetical), please \n * refer do documentation of each priority function for further details:\n *  1. Order by type - [getTypePriority]{@link module:docdash/parse~getTypePriority}\n *  2. Order by method signature scope - [getSignaturePriority]{@link module:docdash/parse~getSignaturePriority}\n *  3. Order by method signature access - [getSignaturePriority]{@link module:docdash/parse~getSignaturePriority}\n *  4. Order in ascending alphabetical order - [getAlphabeticalPriority]{@link module:docdash/parse~getAlphabeticalPriority}\n * \n * @summary Get absolute priority between two nested modules\n * @param {NestedModule} optA - First nested module\n * @param {NestedModule} optB - Second nested module\n * @returns {number}\n */\nconst getPriority = (optA, optB) => {\n    // add priorities together, bit shifting according to priority importance\n    // to ensure that more significant priorities always take precedence\n    return (getTypePriority(optA, optB) << 3) \n        + (getSignaturePriority(optA, optB, \"scope\") << 2) \n        + (getSignaturePriority(optA, optB, \"access\") << 1) \n        + getAlphabeticalPriority(optA, optB)\n}\n\n/**\n * Get type priority between two nested modules, ordering folder types (\"module\"\n * and \"nested-module\") above methods contained in a file in the same submodule.\n * \n * @summary Get type priority between two nested modules\n * @param {NestedModule} optA - First nested module \n * @param {NestedModule} optB - Second nested module \n * @returns {number}\n */\nconst getTypePriority = (optA, optB) => {\n    return optA.type === \"method\" && optB.type != \"method\" ? 1\n        : optA.type != \"method\" && optB.type === \"method\" ? - 1\n        : 0\n}\n\n/**\n * Get signature priority (either access or scope priority as specified in \n * arguments), ordering from least to most \"restrictive\" as listed by jsdoc, a\n * summary of which may be found [here]{@link https://github.com/blameitonyourisp/funky#standard}.\n * \n * @summary Get signature priority between two nested modules\n * @param {NestedModule} optA - First nested module \n * @param {NestedModule} optB - Second nested module \n * @param {\"access\"|\"scope\"} key - switch for sorting access or scope priority\n * @returns {number}\n */\nconst getSignaturePriority = (optA, optB, key) => {\n    const order = key === \"access\"\n        ? [\"public\", \"package\", \"protected\", \"private\"]\n        : [\"global\", \"instance\", \"static\", \"inner\"]\n    // if not found, indexOf will return -1, therefore if both not found return\n    // will be 0\n    return (order.indexOf(optA[key] || \"\") - order.indexOf(optB[key] || \"\")) % 2\n}\n\n/**\n * Get alphabetical priority between two nested modules, by ordering in \n * ascending alphabetical order (A -> Z).\n * \n * @summary Get alphabetical priority between two nested modules\n * @param {NestedModule} optA - First nested module\n * @param {NestedModule} optB - Second nested module \n * @returns {number}\n */\nconst getAlphabeticalPriority = (optA, optB) => {\n    return optA.name.localeCompare(optB.name) % 2\n}\n\n/**\n * Calculate node/fragment of nested module from arguments extracted from DOM -\n * determine type, hierarchy, path, href, and optionally access and scope of \n * fragment.\n * \n * @summary Get fragment of nested module nav structure\n * @param {object} argObj \n * @param {string} argObj.name - basename of fragment\n * @param {HTMLLinkElement} argObj.link - link element from original module nav\n * @param {string} argObj.dir - dirname of fragment relative to src directory\n * @param {NestedModule[]} [argObj.children=[]] - existing children\n * @returns {NestedModule}\n */\nconst getFragment = ({ name, link, dir, children = [] }) => {\n    // fetch href from the html link element and calculate full path of fragment\n    const { href } = link\n    const path = `${dir}_${name}`\n\n    // fragment type; namespace-module for nested modules which do not have any\n    // document members in the code - modules (i.e. modules containing either\n    // methods and optionally other nested modules are initialized to \"file\"\n    // implying that they contain only methods - fragment must be updated to\n    // \"module\" type if submodules are added)\n    const type = methodRegex.test(href) ? \"method\"\n        : children.length ? \"file\" \n        : \"namespace-module\"\n\n    // fragment hierarchy corresponds if fragment is a child, sibling etc.\n    // according to fragment path and the current window location href\n    const hierarchy = absolutePath === path ? \"selected\"\n        : absolutePath.includes(path) ? \"parent\"\n        : childPathRegex.test(path) ? \"child\"\n        : type != \"method\" && siblingPathRegex.test(path) ? \"sibling\"\n        : \"hidden\"\n\n    // if fragment is a method then fetch access and scope from page, otherwise\n    // return with no access or scope\n    if (type === \"method\" && hierarchy === \"child\") {\n        // find doclet element in page corresponding method name in nav\n        const [id] = /** @type {string[]} */ (href.match(/(?<=\\.html#).*$/))\n        const method = /** @type {HTMLElement} */ (document.getElementById(id))\n        \n        // fetch access and scope values from doclet using regex\n        let { access, scope } = /** @type {Object.<string, string>} */ (method\n            .querySelector(\":scope > span\")\n            ?.innerHTML\n            .match(methodSignatureRegex)\n            ?.groups)\n\n        // set defaults if capture group(s) not populated (if the method has\n        // public access and or instance scope, it will not be rendered in page)\n        access ??= \"public\"\n        scope ??= \"instance\"\n\n        return { name, href, type, hierarchy, path, children, access, scope }\n    }\n    else {\n        return { name, href, type, hierarchy, path, children }\n    }\n}\n\n// @exports\nexport { parseModules }","// Copyright (c) 2022 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.  \n// \n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Docdash nested module entry point\n * @module docdash\n * @author James Reid\n */\n\n// @ts-check\n\n// @imports-style\nimport \"../../styles/docdash.css\"\n// @imports-local\nimport { renderNestedModules, renderNestedTitle } from \"../shared/render.js\"\n// @imports-module\nimport { mountNav, mountTitle } from \"./mount.js\"\nimport { parseModules } from \"./parse.js\"\n\n// @body\ntry {\n    // mount nav and title (module nav list may not exist and may throw error)\n    const { navList, moduleNavContainer } = mountNav()\n    const title = mountTitle()\n    \n    // parse existing module nav list into a nested module tree\n    const moduleTree = parseModules(navList)\n    \n    // re-render nav and title\n    renderNestedModules(moduleNavContainer, moduleTree)\n    renderNestedTitle(title)\n} \ncatch (error) { console.error(error) }\n","// Copyright (c) 2022 James Reid. All rights reserved.\n//\n// This source code file is licensed under the terms of the MIT license, a copy\n// of which may be found in the LICENSE.md file in the root of this repository.  \n// \n// For a template copy of the license see one of the following 3rd party sites:\n//      - <https://opensource.org/licenses/MIT>\n//      - <https://choosealicense.com/licenses/mit>\n//      - <https://spdx.org/licenses/MIT>\n\n/**\n * @file Methods for mounting elements in page which need to be re-rendered\n * @module docdash/mount\n * @author James Reid\n */\n\n// @ts-check\n\n// @body\n/**\n * Locates the nav list element for documented modules (rendered under a \n * \"modules\" heading element), and optionally replaces it with a div container\n * for rendering nested modules to. Returns both original nav list and new div.\n * \n * @summary Mounts module nav list and optionally replaces it with div container\n * @static\n * @param {boolean} unmountExisting - Flag indicating if the existing module\n *      nav element should be replaced with the new nested module nav element\n * @returns {{navList: HTMLUListElement, moduleNavContainer: HTMLDivElement}}\n */\nconst mountNav = (unmountExisting = true) => {\n    const nav = document.getElementsByTagName(\"nav\")[0] // fetch nav element\n    const moduleNavContainer = document.createElement(\"div\") // nested container\n\n    // loop over nav element looking for module subsection\n    for (const child of nav.children) {\n        // in module subsection return the located nav list and optionally \n        // replace it in DOM with the container for rendering nested modules\n        if (child.tagName === \"H3\" && child.innerHTML === \"Modules\") {\n            const navList = /** @type {HTMLUListElement} */ (child.nextSibling)\n            if (unmountExisting) { navList.replaceWith(moduleNavContainer) }\n            return { navList, moduleNavContainer }\n        }\n    }\n\n    // throw error in the event that no modules are documented, which will\n    // cause no module section to be generated in the nav\n    throw new Error(\"Module nav list not found\")\n}\n\n/**\n * Locates and returns page H1 title in main div of page\n * \n * @summary Mounts page title\n * @static\n * @returns {HTMLHeadingElement}\n */\nconst mountTitle = () => {\n    return (/** @type {HTMLHeadingElement} */ \n        (document.querySelector(\"div#main h1.page-title\")))\n}\n\nexport { mountNav, mountTitle }"],"names":["styleInject","css","ref","insertAt","document","head","getElementsByTagName","style","createElement","type","firstChild","insertBefore","appendChild","styleSheet","cssText","createTextNode","windowLocation","window","location","href","endsWith","absolutePath","match","methodRegex","childPathRegex","RegExp","source","siblingPathRegex","siblingScopePath","scope","split","slice","regex","methodSignatureRegex","renderNestedModules","moduleNavContainer","moduleTree","list","fragment","title","classList","add","innerHTML","listItem","dataset","hierarchy","access","push","link","name","children","length","sortModuleTree","sort","optA","optB","getPriority","getTypePriority","getSignaturePriority","getAlphabeticalPriority","key","order","indexOf","localeCompare","getFragment","dir","path","test","includes","id","method","getElementById","querySelector","groups","navList","unmountExisting","nav","child","tagName","replaceWith","Error","mountNav","childNode","querySelectorAll","methods","splitPath","last","init","pop","inner","find","obj","Object","assign","parseModules","spanInit","join","spanLast","append","renderNestedTitle","error","console"],"mappings":"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","x_google_ignoreList":[0]}